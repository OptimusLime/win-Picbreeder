//here we test the insert functions
//making sure the database is filled with objects of the schema type
// var wMath = require('win-utils').math;

module.exports = cppnAdditions;

var cppnjs = require('cppnjs');

function cppnAdditions()
{ 
   var self = this;


   self.winFunction = "cppnAdditions";
   
   self.requiredEvents = function(){return [];};
   self.eventCallbacks = function(){return {};};

   self.initialize = function(done)
   {
        //we do our damage here!
         self.addCPPNFunctionsToLibrary();
         done();
   };

   //these are the names of our cppn objects
   var pbActivationFunctions = {sigmoid: 'PBBipolarSigmoid', gaussian: 'PBGaussian', sine: 'Sine', cos: "PBCos", identity: 'pbLinear'};

    //in order to use certain activation functions
    self.addCPPNFunctionsToLibrary = function()
    {
        var actFunctions = cppnjs.cppnActivationFunctions;
        var actFactory = cppnjs.cppnActivationFactory;

         actFunctions[pbActivationFunctions.sigmoid] = function(){
                return new actFunctions.ActivationFunction({
                    functionID: pbActivationFunctions.sigmoid ,
                    functionString: "2.0/(1.0+(exp(-inputSignal))) - 1.0",
                    functionDescription: "Plain sigmoid [xrange -5.0,5.0][yrange, 0.0,1.0]",
                    functionCalculate: function(inputSignal)
                    {
                        return 2.0/(1.0+(Math.exp(-inputSignal))) - 1.0;
                    },
                    functionEnclose: function(stringToEnclose)
                    {
                        return "(2.0/(1.0+(Math.exp(-1.0*" + stringToEnclose + "))) - 1.0)";
                    }
                });
            };

        actFunctions[pbActivationFunctions.gaussian] = function(){
            return new actFunctions.ActivationFunction({
                    functionID: pbActivationFunctions.gaussian,
                    functionString: "2*e^(-(input)^2) - 1",
                    functionDescription:"bimodal gaussian",
                    functionCalculate :function(inputSignal)
                    {
                        return 2 * Math.exp(-Math.pow(inputSignal, 2)) - 1;
                    },
                    functionEnclose: function(stringToEnclose)
                    {
                        return "(2.0 * Math.exp(-Math.pow(" + stringToEnclose + ", 2.0)) - 1.0)";
                    }
                });
            };

        actFunctions[pbActivationFunctions.identity] = function(){
            return new actFunctions.ActivationFunction({
                functionID: pbActivationFunctions.identity,
                functionString: "x",
                functionDescription:"Linear",
                functionCalculate: function(inputSignal)
                {
                    return inputSignal;
                },
                functionEnclose: function(stringToEnclose)
                {
                    return "(" + stringToEnclose + ")";
                }
            });
        };

        actFunctions[pbActivationFunctions.cos] = function(){
           return new actFunctions.ActivationFunction({
                functionID: pbActivationFunctions.cos,
                functionString: "Cos(inputSignal)",
                functionDescription: "Cos function with normal period",
                functionCalculate: function(inputSignal)
                {
                    return Math.cos(inputSignal);
                },
                functionEnclose: function(stringToEnclose)
                {
                    return "(Math.cos(" + stringToEnclose + "))";
                }
            });
        };

        //makes these the only activation functions being generated by picbreeder genotypes
        var probs = {};
        probs[pbActivationFunctions.sigmoid] = .22;
        probs[pbActivationFunctions.gaussian] = .22;
        probs[pbActivationFunctions.sine] = .22;
        probs[pbActivationFunctions.cos] = .22;
        probs[pbActivationFunctions.identity] = .12;
        actFactory.setProbabilities(probs);
    };



    return self;
}